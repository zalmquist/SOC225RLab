---
title: "Lab9: PurpleAir: Australia on Fire"
subtitle: "Soc 225: Data & Society"
author: "[PUT YOUR NAME HERE]"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
---

# Agenda
- Introduction and setup
- Getting the data
- Explore the pas object
- Explore the pat data
- Working with airsensor data

# 1. Introduction and setup

The goal of this module is to demonstrate the use of the **AirSensor** package to explore the smoke impacts of the December 2019 - January 2020 fires and smoke in Australia. This document demonstrates "reproducible research" in that no pre-generated files are needed. Raw data from `PurpleAir` will be downloaded and processed when this script is first run.

In this document we will use the term "sensor" to refer to consumer-grade, PurpleAir air quality sensors sampling at a high time resolution. The term "monitor" will refer to professional-grade, typically government managed 
monitors with hourly data.

The **AirSensor** package has three data models:

* _pas_ (**P**urple**A**ir **S**ynoptic) objects contain snapshots of multiple PA sensors and can be used to make maps.
* _pat_ (**P**urple**A**ir **T**imeseries) objects contain high resolution data for a single sensor.
* _airsensor_ objects contain PA timeseries data that has been quality controlled and aggregated to an hourly time axis.

Think about the following questions: 

**Question 1.1. What type of `AirSensor` data do we need to look at which locations have a moderate to unhealthy 30-minute air quality rating in California?**

**Question 1.2. What type of `AirSensor` data do we need to check air quality recorded by a sensor named "Seattle" between 07-01-2018 and 09-01-2018?**

**Question 1.3. Install and load relevant packages: `tidyverse` for data wrangling and plotting, `PWFSLSmoke` for USFS monitor data access and plotting, `AirSensor` for PurpleAir sensor data access and plotting, `MazamaSpatialUtils` for spatial data download and utility functions, and `AirMonitorPlots` for advanced plots for monitors.**

Note that package `AirMonitorPlots` might not yet be available on CRAN. To install, try the `devtools` package:

```{r}
# Uncomment the below code for installation. Run only once. 

# devtools::install_github('mazamascience/AirMonitorPlots', build_vignettes=TRUE)
```

```{r}
# load all the packages
library(tidyverse)
library(PWFSLSmoke)
library(AirSensor)
library(AirMonitorPlots)
library(MazamaSpatialUtils)
```

# 2. Getting the data

## set up a local archive folder
The `AirSensor` package needs to know where processed data will live. For this report, we will specify a local `archiveBaseDir` where downloaded and processed data will live. 
```{r}

archiveBaseDir <- "Australia_on_fire" # assign a name to the new local folder

if (file.exists(archiveBaseDir)) { # check if the same-named folder exists
 cat("The folder already exists") # if a same-named folder exists, print the warning
} else {
 dir.create(archiveBaseDir) # if no same-named folder, create the folder
}

setArchiveBaseDir(archiveBaseDir) # sets the package base directory pointing to an archive of pre-generated data files
```

## Load synoptic data for Australia

We will use the `pas_createNew()` function to create a *pas* object containing all the spatial metadata associated with purple air monitors in Australia. 

To create a new `pas` object you must first properly initialize the `MazamaSpatialUtils` package. 

```{r}
filePath_pas <- file.path(archiveBaseDir, "pas_au.rda")
setSpatialDataDir(archiveBaseDir) # set package data directory
installSpatialData('NaturalEarthAdm1') # install required spatial data
setSpatialDataDir(archiveBaseDir)

initializeMazamaSpatialUtils() # initialize the package
```

Now we create the `pas` object and save it into an .rda file. This can take up to a minute to process. 

```{r}
pas_au <- pas_createNew(countryCodes = "AU", includePWFSL = TRUE) # Download, parse and enhance synoptic data from PurpleAir and return the results as a useful tibble with class pa_synoptic.

# saving and loading the downloaded local file
save(pas_au, file = "pas_au.rda") # save the synoptic data into an .rda file

pas <- get(load("pas_au.rda")) # load data from the .rda file
```

A `pas` object is a dataframe that contains metadata and PM 2.5 averages for many purple air sensors in a designated region. Each `pas` object can be filtered and edited to retain whichever collection of sensors the analyst desires based on location, state, name, etc.

It is important to note that the data averages in the pas object – the numeric values for PM2.5 or temperature or humidity – are current at the time that the pas is created. pas objects can be used to quickly explore the spatial distribution of PurpleAir sensors and display some then-current values but should not be used for detailed analysis.

**Question 2.1. Create a `pas` object with current data in US. Save this `pas` file to your computer for homework use.**

```{r}
# pas_us <- pas_createNew(countryCodes = "US")
```

## View a *pas* map

We can view the locations of each sensor and the AQI (Air Quality Index) maxima (when the pas was created) using the pas_leaflet() function.
```{r}
pas_leaflet(pas)
```

We can also explore and utilize other PurpleAir sensor data. Check the `pas_leaflet()` documentation for all supported parameters. By default, `pas_leaflet()` will map the coordinates of each PurpleAir sensor and the hourly PM2.5 data. 

Here is an example of humidity data captured from PurpleAir sensors across the state of New South Wales.
```{r}
pas %>% 
  pas_filter(stateCode == "NS") %>% 
  pas_leaflet(parameter = "humidity")
```

**Question 2.2. Use your `pas` object on US, map the hourly PM2.5 data in California.**
```{r}

```

## Load time series data for a sensor

PurpleAir sensor readings are uploaded to the cloud every 120 seconds where they are stored for download and display on the PurpleAir website. After every interval, the synoptic data is refreshed and the outdated synoptic data is then stored in a *ThingSpeak* database. In order to access the *ThingSpeak* channel API we must first load the synoptic database. 

Let’s look at data from a sensor in the Australia for the time period covering the . One of those sensors is labeled “Wallerawang”. We will look over the time period 2022-01-01 to 2022-03-01.

```{r}
label <- c("Wallerawang")
pat_Wallerawang <- pat_createNew(
    pas = pas, 
    label = label, 
    startdate = 20220101, 
    enddate = 20220301
  )

save(pat_Wallerawang, file = "pat_Wallerawang.rda")
```

## View a *pat* timeseries

A `pat` object is a list of two dataframes, one called meta containing spatial metadata associated with the sensor and another called data containing that sensor’s time series data. Each pat object contains time series data for a temperature channel, a humidity channel, A and B PM 2.5 channel’s, and several other fields.

The following chunk demonstrates use of the `pat_multiPlot()` function to have a quick look at the data contained in a pat object. The plot shows both A and B channels as well as temperature and humidity. The plotting function is flexible and has options for choosing which channels to display, on the same or individual axes. (Type ?pat_multiPlot to learn more.)

```{r}
pat_multiplot(pat_Wallerawang)
```

In this case we see that the data look good. Channels A and B are both showing lots of PM 2.5 data for “Jannali” over the period of interest. 

**Question 2.3. Use the `pas` object you generated on US to create a `pat` object on a sensor named "Seattle" for the time period 2018-07-01 to 2018-09-01. Name it `pat_seattle`. Plot this `pat` object. What do you find?**

```{r}
# pat_seattle <- pat_createNew(label = "Seattle", 
#                      pas = pas_us, 
#                      startdate = 20180701, 
#                      enddate = 20180901)
# 
# pat_seattle %>%
#   pat_multiPlot(plottype = "all")
```


# 3. Explore the *pas* object

For the purposes of this exploratory example, we are focusing on Australia but maybe we want to filter even more and just look at the sensors within a certain radius of the one we chose in Sydney.

```{r}
lon <- pat_Wallerawang$meta$longitude # get the longitude of sensor "Wallerawang"
lat <- pat_Wallerawang$meta$latitude # get the latitude of sensor "Wallerawang"

pas_sydney <- 
  pas_au %>%
  pas_filterNear( # Filter for PurpleAir sensors within a                       # specified distance from specified target                    # coordinates.
    longitude = lon, 
    latitude = lat, 
    radius = "50 km"
  ) 

pas_leaflet(pas_sydney)
```

**Question 3.1. Use the `pas` object on US, filter (`pas_filter`) and plot (`pas_leaflet`) which locations have a moderate to unhealthy 6-hour average air quality rating (pm25_6hr equal to or higher than 25) in California.**
(Check the hint if you have troubles)

```{r}

```

# 4. Explore the *pat* object

## Download and plot `pat` data

We can create `pat` objects for sensors listed in the `pas`. Since the fires in Australia started, new PurpleAir sensors have been popping up left and right. Let’s start by grabbing data from sensors with the longest history.

```{r}
startdate <- 20191210
enddate <- 20200110

pat_chisholm <- pat_createNew(
    label = "Chisholm",
    pas = pas_au,
    startdate = startdate,
    enddate = enddate
  )

pat_moruya <- pat_createNew(
    label = "MORUYA HEADS",
    pas = pas_au,
    startdate = startdate,
    enddate = enddate
  )

pat_windang <- pat_createNew(
    label = "Windang, Ocean Street",
    pas = pas_au,
    startdate = startdate,
    enddate = enddate
  )
```

In order to look for patterns, we can look at the PM2.5 data recorded on channel A from all the sensors. This chunk uses `ggplot2` to view all the data on the same axis.

```{r}
colors <- c(
  "Chisholm" = "#1b9e77", 
  "Moruya" = "#d95f02", 
  "Windang" = "#7570b3"
)

gg <- ggplot(data = pat_chisholm$data) +
  geom_point(aes(x = pat_chisholm$data$datetime, 
                 y = pat_chisholm$data$pm25_A, 
                 color = "Chisholm"), alpha = 0.5) +
  geom_point(data = pat_moruya$data, 
             aes(x = pat_moruya$data$datetime, 
                 y = pat_moruya$data$pm25_A,
                 color = "Moruya"), alpha = 0.5) +
  geom_point(data = pat_windang$data, 
             aes(x = pat_windang$data$datetime, 
                 y = pat_windang$data$pm25_A, 
                 color = "Windang"), alpha = 0.5) +
  labs(title = "PM 2.5 channel A for multiple sensors" ) +
  xlab("date") +
  ylab("ug/m3") +
  scale_colour_manual(name="Sensor",values=colors) +
  theme(legend.position= c(0.9, 0.8))

print(gg)
```

**Question 4.1. What do you find from the above graph? What other information would you check to confirm your findings?**

**Question 4.2. Let’s check a few other sensors that are closer in proximity to Chisholm to see if they are also reporting abnormal values. Download and plot data on sensors "Bungendore, NSW Australia" and "Downer" together with "Chisholm" for the same time period. Make your plot easy to read. What do you find?**
```{r}

```

**Question 4.3. Are there any other factors that may impact the validity of the sensor data we observed?**

## Sensor State-of-Health

The `pat` data quality can degrade over time. For a quick sanity check, we can use the `pat_dailySoHIndexPlot()` function to plot the daily State-of-Health index. This function plots both channels A and B with a daily State-of-Health index along the bottom.

```{r}
pat_dailySoHIndexPlot(pat_chisholm)
```

**Question 4.4. Plot and evaluate the state-of-health for a sensor we just looked at.**
```{r}

```


**Question 4.5. Can we make the conclusion that the smoke in Sydney area was clearly very bad over our time period of interest?**

# 5. Working with *airsensor* data

## Plot the daily average air quality

Another way to look at the PurpleAir sensor data is to convert the `pat` into an `airsensor` object. The following chunk aggregates data from a `pat` object into an `airsensor` object with an hourly time axis. 

Because we are dealing with values far outside the norm, we will use the `PurpleAirQC_hourly_AB_00` function which performs minimal quality control. See [RDocumentation](https://cran.r-project.org/web/packages/AirSensor/AirSensor.pdf) of the package for more details. 

```{r}
# create an airsensor object
airsensor_chisholm <- pat_createAirSensor(
  pat = pat_chisholm,
  parameter = "pm25",
  FUN = PurpleAirQC_hourly_AB_00
)
```

## Advanced plotting
Now that we have converted the relative raw `pas` into an `airsensor` object, we can use any of the “monitor” plotting functions found in the `PWFSLSmoke` or `AirMonitorPlots` packages. 

```{r}
AirMonitorPlots::monitor_ggDailyBarplot(airsensor_chisholm)
```

Here, the bar associated with each day is colored by Air Quality Index (AQI). Over this time period there were only 10 days where the daily average AQI was below “Unhealthy”. 

**Question 5.1. Now come back to your `pat_seattle` object. Make a daily average PM2.5 bar graph using the object. Describe your findings.**
```{r}

```


## Incorporating wind data
To get a sense of what direction smoke is coming from, we use the
sensor_PolluationRose() function. As the name implies, this function takes an airsensor object as an argument. It then obtains hourly wind direction and speed data from the nearest meteorological site and plots a traditional wind rose plot for wind direction and PM2.5.

In this case, it looks like the smoke is coming mostly from the E/NE which is validated by this wind rose plot from the Australian Bureau of Meteorology [here](http://www.bom.gov.au/cgi-bin/climate/cgi_bin_scripts/windrose_selector.cgi?period=Dec&type=9&location=72150).

```{r}
sensor_pollutionRose(sensor = airsensor_chisholm)
```
**Question 5.2. Check the wind direction of your `pat_seattle` object.**
```{r}

```


Hint

3.1. Your code should look like this:
```{r}
pas %>% 
  pas_filter(stateCode == 'CA') %>% 
  pas_filter(pm25_6hr >= 25.0) %>% 
  pas_leaflet(parameter = "pm25_6hr")
```

# References
Kayleigh Wilson & Jonathan Callahan, [Australia on Fire](https://mazamascience.github.io/AirSensor/articles/articles/Australia_on_fire.html)