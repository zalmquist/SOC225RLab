---
title: "Lab10: Fitbit"
subtitle: "Soc 225: Data & Society"
author: "[PUT YOUR NAME HERE]"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
---

```{r,message=FALSE,warning=FALSE}
## Run this code, to manage packages and install as needed.
# Install pacman
if (!require("pacman")) install.packages("pacman", repos = "http://cran.us.r-project.org")
# p_load function loads packages if installed, or install then loads otherwise
pacman::p_load(tidyverse,tidyverse,lubridate,VennDiagram,janitor,skimr,DataExplorer)
```


# Agenda
- Introduction and setup
- Data pre-processing
- Explore and analyze data
 - What is smart device usage by features?
 - How are variables distributed?
 - Is there any trend in daily usage?
 - How should we group users?
- Challenge: trends on performance among user groups

# 1. Introduction and setup

We'll be using Fitbit Fitness Tracker data to perform a usage trend analysis in this module. These data sets were generated by respondents to a distributed survey via Amazon Mechanical Turk between 03.12.2016-05.12.2016. Thirty three eligible Fitbit users consented to the submission of personal tracker data, including minute-level output for physical activity, heart rate, and sleep monitoring. Individual reports can be parsed by export session ID (column A) or timestamp (column B). Variation between output represents use of different types of Fitbit trackers and individual tracking behaviors / preferences. For more information about the data, refer to this [website](https://www.kaggle.com/mimosabella/fitness-tracker-a-usage-trends-analysis-with-r).

We'll be using the following data sets: *Daily Activity*, *Sleep Day* and *Heart Rate*. 

The following packages will be used: `tidyverse`, `lubridate` for dealing with Dates, `VennDiagram` to generate Venn Digram, `janitor` that expedite the initial data exploration, `skimr` for compact and flexible summaries of data, and `DataExplorer` for fast exploratory data analysis. 

**Question 1.1. Install and load required packages. Read csv files into data frames. Assign the following names: daily_activity, sleep_day, heart_rate.**

**Reminder that because we are using a server the libraries will be installed from the pacman script**

```{r}
# library(tidyverse)
# library(lubridate)
# library(VennDiagram)
# library(janitor)
# library(skimr)
# library(DataExplorer)
```

```{r}
# daily_activity <- read_csv("Data/dailyActivity_merged.csv")
# sleep_day <- read_csv("Data/sleepDay_merged.csv")
# heart_rate <- read_csv("Data/heartrate_seconds_merged.csv")
```

**Question 1.2. Use `head()` to inspect the data frames. What variables do they contain? What does each row represent? **

```{r}

```

**Question 1.3. Discuss possible limitations of the data set. What kind of additional information would be helpful to expand our scope of analysis?**

Let's further check if data contains missing values. 
```{r}
sum(is.na(daily_activity))
sum(is.na(sleep_day))
sum(is.na(heart_rate))
```
There are many question we can answer by analyzing the data. Examples are:
- What is smart device usage by features?
- How are variables distributed?
- Is there any trend in daily usage?
- How should we group users?
- Are there any trends on performance among groups?

We'll be preparing and analyzing data to answer these questions. 

# 2. Data pre-processing

We will do some basic clean-up of the data frames we just read. 
```{r}
# Prepare daily_activity table:
daily <- daily_activity %>% 
  clean_names() %>% # clean name of variables
  mutate(activity_date = mdy(activity_date), day_week = weekdays(activity_date)) %>% # generate Date format
  rename(date = activity_date) %>% 
  select(-c(5:10)) # drop redundant columns
head(daily)
```


```{r}
# Prepare sleep_day table
sleep <- sleep_day %>% 
  clean_names() %>% 
  separate(col = sleep_day, c("date", "sleep_time"), sep = " ") %>% # turns a single character column into multiple columns 
  mutate(date = mdy(date),
         day_week = weekdays(date)) %>% 
  rename("sleep_records" = "total_sleep_records",
        "asleep_mins" = "total_minutes_asleep",
        "bed_mins" = "total_time_in_bed") %>% 
  select(-"sleep_time")
```

**Question 2.1. Follow the example and instructions below to clean up the `heart_rate` data frame. Name this new data frame `heartrate`.**
(Check the hints if you have troubles)
```{r}
heartrate <- heart_rate %>% 
   # clean up variable names
   # change the `time` column into mdy_hms Date format
   # separate `time` column into two columns "date" and "datetime", separated by space 
   # remove columns "datetime" and "value"
   # group by id and date
   # summarise the data frame and drop all levels of grouping
```


# 3. Data exploration

## What is smart device usage by features?

```{r}
# Generate 3 sets of unique Ids for each feature.
step_ids <- unique(daily$id, incomparables = FALSE)
sleep_ids <- unique(sleep$id, incomparables = FALSE)
heartrate_ids <- unique(heartrate$id, incomparables = FALSE)

# Plot
venn <- venn.diagram(x = list(step_ids, sleep_ids, heartrate_ids),
  category.names = c("Steps count", "Sleep monitor", "Heart monitor"),
  filename = "features_venn.png",
  output=TRUE, imagetype="png",
  lwd = 2, fill = c("skyblue", "pink1", "mediumorchid"))
```

**Question 3.1. Take a look at the Venn diagram we just created. How many users have Steps count? How many users have both Steps count and Sleep tracking records? How many users have all three featured records of Steps-Sleep-Heartrate?**

Let's focus on two key features, Steps and Sleep records. 

**Question 3.2. Check which IDs have both Steps and Sleep records?**
(Check the hint if you have troubles)

**Question 3.3. Join data frame `daily` and `sleep` to enable further observations by using common keys "id", "date" and "day_week". Observe your Venn diagram. Which data frame should be on the left when using `left_join`? Name this new data frame `step_sleep`.**
```{r}
step_sleep <- sleep %>% 
  left_join(daily, by = c("id","date","day_week"))
```

We further check if the new data frame contain duplicated rows. 
```{r}
step_sleep[duplicated(step_sleep),] #check for rows that are duplicated in the data frame
```

**Question 3.4. Remove duplicated rows of `step_sleep`.**
(check the hints if you have troubles)

**Question 3.5. Check for number of rows in your data frame and number of unique user id. Does the number of users match your answer in 3.1?**

```{r}

```


## How are variables distributed?

Now let's take a look at the shape and distribution of the variables of the new data frame we have so far, using the `plot_histogram` function from the `DataExplorer` package. `plot_histogram` creates histogram for each continuous feature in the data frame. 

```{r}
step_sleep %>% select(-c("id", "sleep_records")) %>% plot_histogram(ncol = 3, ggtheme = theme_light())

```
What do you find?

## Is there any trend in daily usage?

Let's first gather a few ideas how users use their devices at a day level. 
```{r}
# Get number of users used their devices each day
obs_users <- step_sleep %>% 
  group_by(date) %>% 
  summarise(user_perday = sum(n()), .groups = "drop") 
```


**Question 3.6. Get a summary of users per day from the `obs_users` data frame. Rank top 10 days with largest users. What do you find?**

```{r}

```

**Question 3.7. Follow the example above, get the number of days a user used their device in a 31 day period. Name this new data frame `obs_days`.**

```{r}
obs_days <- step_sleep %>% group_by(id) %>% 
  summarise(num_dayuse = sum(n()), .groups = "drop") %>% 
  arrange(-num_dayuse)
```
- Of a total of 24 Ids (100%), the number of users who used their devices daily can vary from as little as 33% (8 users) to as many as 71% (17 users) each day. The greatest number of users per day is around double that of the least number of user per day.

- Participants used their devices more frequently in the first half of the period than days towards the end.

## How should we group users?

Let's classify users into usage ranges:
```{r}
usage <- obs_days %>% 
  mutate(group = case_when(
    between(num_dayuse, 1, 10) ~ "low usage",
    between(num_dayuse, 11, 20) ~ "moderate usage",
    between(num_dayuse, 21, 31) ~ "high usage",
    TRUE ~ NA_character_ 
    ))
```

**Question 3.8. Now, create a new data frame by left joining `usage` with `step_sleep`. Name this new data frame `usage_df`.**
```{r}
usage_df <- step_sleep %>% 
  left_join(usage, by = "id")
```

**Question 3.9. How should we compute percentage of each usage groups? Follow the steps below to generate a new data frame `sum_usage`.**
```{r}
sum_usage <- usage %>% 
  # converting `group` into factor, using `mutate` and `fct_relevel`
  # group by `group`
  # summarise and get `num_users` as count of rows for each group
  # generate a new column `percent` that equals to the number of users each group divided by the total number of users, times 100
```

What do you find?

# 4. Challenge: trends on performance among groups

A challenge for you is to observe and analyze if there are any trends on performance among groups. For example, you can summarize average active minutes (very active/fairly active/lighly active) for each group, and make a comparison. Further analysis could include grouping by day of the week and group of users, then summarize the average active time. If you are interested in comparing low active, inactive or rest hours among groups, you can use the data to explore as well. Many possibilities!

(Check the hints for an example if you are stuck!)

```{r}

```

Hint
2.1. Your code should look like this:
```{r}
# Prepare heartrate data
heartrate <- heart_rate %>% 
  clean_names() %>% 
  mutate(time = mdy_hms(time)) %>% 
  separate(col = time, into = c("date", "datetime"), sep = " ") %>% 
  select(-c(datetime, value)) %>% 
  group_by(id, date) %>% 
  summarise(.groups = "drop")
```

3.2. Your code could look like this:
```{r}
# Check which IDs have both STEPS and SLEEP records:
sleep_ids[sleep_ids %in% step_ids]
```

3.4. Your code could look like this:
```{r}
step_sleep <- step_sleep[!duplicated(step_sleep),]
```

4. Summarize active minutes by days:
```{r}
active1 <- usage_df %>% 
  group_by(group) %>% 
  summarise(very_active = round(mean(very_active_minutes),0),
            fairly_active = round(mean(fairly_active_minutes),0), .groups = "drop")


# Reshape data 
active1_long <- gather(data = active1, key = "variables", value = "value", -group) # convert data from wide format to long format, see more in ?dplyr. 

# Plot very active and fairly active minutes per day
active1_long %>% 
  na.omit() %>% 
  ggplot()+ geom_col(aes(x= group, y=value, group=variables, fill=variables))+
  theme(axis.text.x = element_text(size = 9))+
  labs(x="Group of users" , y="Minutes")+
  ggtitle("Comparison of Average Active Minutes")

```

# References
[Fitness Tracker: A Usage Trends Analysis with R](https://www.kaggle.com/mimosabella/fitness-tracker-a-usage-trends-analysis-with-r)

